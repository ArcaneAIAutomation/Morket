# Requirements Document

## Introduction

Module 1 establishes the foundational OLTP backend and user state management for Morket, a modern GTM data engine. This module provides the core API gateway, user authentication, workspace management, credit system, and audit logging that all future modules (enrichment orchestration, scraping, spreadsheet UI) will build upon. The system is designed for multi-tenancy, horizontal scalability, and consumption-based billing.

## Glossary

- **API_Gateway**: The Express.js server that receives all HTTP requests, applies middleware (auth, validation, rate limiting, logging), and routes them to controllers.
- **User**: A registered individual identified by email and hashed password, who can belong to multiple Workspaces.
- **Workspace**: A multi-tenant organizational unit that groups Users, API Credentials, Credit Balances, and Audit Logs.
- **Workspace_Membership**: The association between a User and a Workspace, including a role (owner, admin, member, viewer).
- **RBAC_Middleware**: Middleware that enforces Role-Based Access Control by checking a User's role within a Workspace against the required permission for an endpoint.
- **Credit_Balance**: A numeric balance associated with a Workspace, consumed by enrichment actions and replenished by deposits.
- **Credit_Transaction**: An immutable ledger entry recording a credit deposit, withdrawal, or adjustment against a Workspace.
- **API_Credential**: An encrypted record storing a third-party API key (e.g., Apollo, Clearbit) belonging to a Workspace.
- **Audit_Log**: An append-only record of significant actions performed within a Workspace, capturing who did what and when.
- **Access_Token**: A short-lived JWT issued upon authentication, used to authorize API requests.
- **Refresh_Token**: A long-lived token used to obtain new Access_Tokens without re-authentication.
- **API_Key**: A programmatic access credential generated by a User for a Workspace, used for machine-to-machine API calls.
- **JSON_Envelope**: The standard API response format: `{ success: boolean, data: T | null, error: string | null }`.

## Requirements

### Requirement 1: Core API Gateway

**User Story:** As a developer integrating with Morket, I want a consistent and well-structured API gateway, so that all requests are validated, authenticated, rate-limited, and return predictable response formats.

#### Acceptance Criteria

1. THE API_Gateway SHALL return all responses in the JSON_Envelope format `{ success, data, error }`
2. WHEN a request fails input validation, THE API_Gateway SHALL return a 400 status code with a descriptive error message in the JSON_Envelope
3. WHEN an unauthenticated request is made to a protected endpoint, THE API_Gateway SHALL return a 401 status code in the JSON_Envelope
4. WHEN an authenticated request lacks the required role for an endpoint, THE API_Gateway SHALL return a 403 status code in the JSON_Envelope
5. WHEN a client exceeds the configured rate limit, THE API_Gateway SHALL return a 429 status code in the JSON_Envelope
6. WHEN an unhandled error occurs during request processing, THE API_Gateway SHALL return a 500 status code with a generic error message and log the detailed error internally
7. THE API_Gateway SHALL log each incoming request with method, path, status code, and response time

### Requirement 2: User Registration and Authentication

**User Story:** As a user, I want to register and log in securely with email and password, so that I can access my workspaces and data.

#### Acceptance Criteria

1. WHEN a user submits a valid email and password, THE Authentication_System SHALL create a new User record with the password hashed using bcrypt
2. WHEN a user submits valid login credentials, THE Authentication_System SHALL return an Access_Token and a Refresh_Token
3. WHEN a user submits invalid login credentials, THE Authentication_System SHALL return a 401 status code without revealing whether the email or password was incorrect
4. THE Authentication_System SHALL issue Access_Tokens with a configurable expiry (default 15 minutes)
5. THE Authentication_System SHALL issue Refresh_Tokens with a configurable expiry (default 7 days)
6. WHEN a valid Refresh_Token is presented, THE Authentication_System SHALL issue a new Access_Token and rotate the Refresh_Token
7. WHEN an expired or revoked Refresh_Token is presented, THE Authentication_System SHALL return a 401 status code
8. WHEN a user requests a password reset, THE Authentication_System SHALL generate a time-limited reset token and send it to the registered email
9. WHEN a valid password reset token is submitted with a new password, THE Authentication_System SHALL update the User's password hash and invalidate all existing Refresh_Tokens for that User

### Requirement 3: API Key Management

**User Story:** As a developer, I want to generate API keys for programmatic access to Morket, so that I can integrate Morket into automated workflows without using interactive login.

#### Acceptance Criteria

1. WHEN a user requests API key generation for a Workspace, THE Authentication_System SHALL create an API_Key scoped to that Workspace with the User's role permissions
2. THE Authentication_System SHALL display the full API_Key value only once at creation time
3. WHEN an API request includes a valid API_Key in the authorization header, THE API_Gateway SHALL authenticate the request with the permissions of the associated User and Workspace
4. WHEN a user revokes an API_Key, THE Authentication_System SHALL immediately invalidate the key so subsequent requests using the key are rejected
5. THE Authentication_System SHALL store API_Keys as hashed values so that raw key values are not recoverable from the database

### Requirement 4: Role-Based Access Control

**User Story:** As a workspace owner, I want to assign roles to members, so that I can control who can view, edit, or administer workspace resources.

#### Acceptance Criteria

1. THE RBAC_Middleware SHALL enforce a role hierarchy where owner > admin > member > viewer
2. WHEN a request requires a minimum role of "admin", THE RBAC_Middleware SHALL permit access for users with the "admin" or "owner" role and deny access for "member" or "viewer"
3. WHEN a user has no Workspace_Membership for the target Workspace, THE RBAC_Middleware SHALL deny access with a 403 status code
4. WHEN a role check is performed, THE RBAC_Middleware SHALL use the User's role within the specific Workspace context, not a global role
5. THE RBAC_Middleware SHALL allow only the "owner" role to delete a Workspace or transfer ownership

### Requirement 5: Workspace Management

**User Story:** As a user, I want to create and manage workspaces, so that I can organize my team's data enrichment activities in isolated environments.

#### Acceptance Criteria

1. WHEN a user creates a Workspace, THE Workspace_Service SHALL create the Workspace record and assign the creating User as "owner"
2. WHEN a workspace owner or admin invites a user by email, THE Workspace_Service SHALL create a pending invitation and send an email notification
3. WHEN an invited user accepts an invitation, THE Workspace_Service SHALL create a Workspace_Membership with the role specified in the invitation
4. WHEN a workspace owner or admin changes a member's role, THE Workspace_Service SHALL update the Workspace_Membership record accordingly
5. WHEN a workspace owner or admin removes a member, THE Workspace_Service SHALL delete the Workspace_Membership and revoke any API_Keys scoped to that User and Workspace
6. THE Workspace_Service SHALL prevent the last owner of a Workspace from being removed or having their role downgraded
7. WHEN a user requests their list of workspaces, THE Workspace_Service SHALL return only Workspaces where the User has an active Workspace_Membership

### Requirement 6: API Credential Storage

**User Story:** As a workspace admin, I want to securely store third-party API keys, so that enrichment actions can authenticate with external data providers on behalf of my workspace.

#### Acceptance Criteria

1. WHEN a workspace admin stores an API credential, THE Credential_Service SHALL encrypt the credential value using AES-256-GCM before persisting it to the database
2. WHEN an authorized service requests a credential for an enrichment action, THE Credential_Service SHALL decrypt and return the credential value
3. THE Credential_Service SHALL store each API_Credential with a provider name, an encrypted value, and the Workspace it belongs to
4. WHEN a workspace admin deletes an API credential, THE Credential_Service SHALL permanently remove the encrypted record from the database
5. THE Credential_Service SHALL prevent retrieval of raw credential values through any user-facing API endpoint; only internal services may decrypt credentials

### Requirement 7: Credit System

**User Story:** As a workspace owner, I want a consumption-based credit system, so that my team's usage of enrichment actions is tracked and billed accurately.

#### Acceptance Criteria

1. WHEN a Workspace is created, THE Credit_Service SHALL initialize the Credit_Balance to zero
2. WHEN credits are deposited into a Workspace, THE Credit_Service SHALL increase the Credit_Balance and record a Credit_Transaction with type "deposit"
3. WHEN an enrichment action consumes credits, THE Credit_Service SHALL decrease the Credit_Balance and record a Credit_Transaction with type "withdrawal"
4. IF a withdrawal would cause the Credit_Balance to go below zero, THEN THE Credit_Service SHALL reject the withdrawal and return an insufficient credits error
5. THE Credit_Service SHALL ensure that concurrent credit operations on the same Workspace produce a correct final balance (no lost updates or double-spending)
6. WHEN the Credit_Balance of a Workspace falls below a configurable threshold, THE Credit_Service SHALL emit a low-balance alert event
7. THE Credit_Service SHALL maintain an immutable Credit_Transaction ledger where entries are append-only and existing entries are never modified or deleted
8. WHEN a user queries the credit history, THE Credit_Service SHALL return Credit_Transactions in reverse chronological order with pagination support

### Requirement 8: Audit Logging

**User Story:** As a compliance officer, I want an immutable audit log of all significant actions, so that I can review who did what and when for security and compliance purposes.

#### Acceptance Criteria

1. WHEN a significant action occurs (user login, role change, credential access, credit transaction, workspace modification), THE Audit_Service SHALL create an Audit_Log entry with actor, action, target resource, timestamp, and Workspace context
2. THE Audit_Service SHALL ensure Audit_Log entries are append-only and existing entries are never modified or deleted
3. WHEN a user queries the audit log for a Workspace, THE Audit_Service SHALL return entries filtered by Workspace with pagination and optional date range filtering
4. THE Audit_Service SHALL record audit entries asynchronously so that audit logging does not increase API response latency

### Requirement 9: Database Schema and Migrations

**User Story:** As a developer, I want a well-structured database schema with versioned migrations, so that the database can be reliably evolved across environments.

#### Acceptance Criteria

1. THE Migration_System SHALL manage all schema changes through versioned, sequential migration files
2. THE Migration_System SHALL support both "up" (apply) and "down" (rollback) operations for each migration
3. THE Database_Schema SHALL use parameterized queries for all database operations to prevent SQL injection
4. THE Database_Schema SHALL define foreign key constraints to enforce referential integrity between Users, Workspaces, Workspace_Memberships, API_Credentials, Credit_Transactions, and Audit_Logs

### Requirement 10: Environment Configuration

**User Story:** As a DevOps engineer, I want strict environment configuration validation, so that the application fails fast on startup if required configuration is missing or invalid.

#### Acceptance Criteria

1. WHEN the application starts, THE Configuration_Service SHALL validate all environment variables against a Zod schema
2. IF a required environment variable is missing or invalid, THEN THE Configuration_Service SHALL terminate the application with a descriptive error message
3. THE Configuration_Service SHALL load configuration from environment variables via dotenv and never from hardcoded values
4. THE Configuration_Service SHALL ensure that secret values (database passwords, encryption keys, JWT secrets) are never logged or included in API responses
